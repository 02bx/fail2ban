#!/usr/bin/env python
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: t -*-
# vi: set ft=python sts=4 ts=4 sw=4 noet :
"""Script to run Fail2Ban tests battery
"""

# This file is part of Fail2Ban.
#
# Fail2Ban is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Fail2Ban is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Fail2Ban; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

__author__ = "Cyril Jaquier"
__copyright__ = "Copyright (c) 2004 Cyril Jaquier, 2012- Yaroslav Halchenko"
__license__ = "GPL"

import logging
import os
import sys
import time
import unittest

# Check if local fail2ban module exists, and use if it exists by
# modifying the path. This is such that tests can be used in dev
# environment.
if os.path.exists("fail2ban/__init__.py"):
	sys.path.insert(0, ".")
from fail2ban.version import version

from fail2ban.tests.utils import initProcess, gatherTests
from fail2ban.setup import updatePyExec

from optparse import OptionParser, Option

# Update fail2ban-python env to current python version (where f2b-modules located/installed)
bindir = os.path.dirname(
	# __file__ seems to be overwritten sometimes on some python versions (e.g. bug of 2.6 by running under cProfile, etc.):
	sys.argv[0] if os.path.basename(sys.argv[0]) == 'fail2ban-testcases' else __file__
)
updatePyExec(bindir)

def get_opt_parser():
	# use module docstring for help output
	p = OptionParser(
				usage="%s [OPTIONS] [regexps]\n" % sys.argv[0] + __doc__,
				version="%prog " + version)

	p.add_options([
		Option('-l', "--log-level", type="choice",
			   dest="log_level",
			   choices=('heavydebug', 'debug', 'info', 'notice', 'warning', 'error', 'critical'),
			   default=None,
			   help="Log level for the logger to use during running tests"),
		Option('-v', "--verbosity", action="store",
			   dest="verbosity", type=int,
			   default=None,
			   help="Set numerical level of verbosity (0..4)"),
		Option("--log-direct", action="store_false",
			   dest="log_lazy",
			   default=True,
			   help="Prevent lazy logging inside tests"),
		Option('-n', "--no-network", action="store_true",
			   dest="no_network",
			   help="Do not run tests that require the network"),
		Option('-g', "--no-gamin", action="store_true",
			   dest="no_gamin",
			   help="Do not run tests that require the gamin"),
		Option('-m', "--memory-db", action="store_true",
			   dest="memory_db",
			   help="Run database tests using memory instead of file"),
		Option('-f', "--fast", action="store_true",
			   dest="fast",
			   help="Try to increase speed of the tests, decreasing of wait intervals, memory database"),
		Option('-i', "--ignore", action="store_true",
			   dest="negate_re",
			   help="negate [regexps] filter to ignore tests matched specified regexps"),
		Option("-t", "--log-traceback", action='store_true',
			   help="Enrich log-messages with compressed tracebacks"),
		Option("--full-traceback", action='store_true',
			   help="Either to make the tracebacks full, not compressed (as by default)"),

		])

	return p

parser = get_opt_parser()
(opts, regexps) = parser.parse_args()

#
# Process initialization corresponding options (logging, default options, etc.)
#
opts = initProcess(opts)
verbosity = opts.verbosity

#
# Let know the version
#
if opts.log_level != logging.CRITICAL: # pragma: no cover
	print("Fail2ban %s test suite. Python %s. Please wait..." \
			% (version, str(sys.version).replace('\n', '')))

tests = gatherTests(regexps, opts)
#
# Run the tests
#
testRunner = unittest.TextTestRunner(verbosity=verbosity)

tests_results = testRunner.run(tests)

if not tests_results.wasSuccessful(): # pragma: no cover
	sys.exit(1)
